---
// This component will be client-side rendered to handle Spotify API calls


---

<div id="now-playing" class=" bg-white border border-[#FEE96A]/30 rounded-lg shadow-lg px-4 py-2 w-full hidden max-w-md">
  <a href="#" id="spotify-link"  target="_blank">
  <div class="flex items-center space-x-3">
    <div id="album-art" class="w-12 h-12 bg-gray-200 rounded flex-shrink-0">
      <img id="album-image" src="" alt="Album Art" class="w-full h-full rounded object-cover hidden">
    </div>
    <div class="flex-1 min-w-0">
      <div id="track-info" class="text-sm">
        <p id="track-name" class="font-medium text-[#064161] truncate">Loading...</p>
        <p id="artist-name" class="text-[#064161]/70 truncate">Loading...</p>
      </div>
     
    </div>
    <div class="flex flex-col items-center space-y-1">
      
      <div id="spotify-logo" class="w-4 h-4">
        <svg viewBox="0 0 24 24" fill="#1DB954">
          <path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/>
        </svg>
      </div>
    </div>
  </div>
  </a>
</div>

<script>
  import { supabase } from '../lib/supabase';

  // Store the last successfully fetched data
  let lastSuccessfulData = null;
  let isInitialized = false;

  const updateDisplay = (trackData, isOnline = true) => {
    // console.log('trackData', trackData);
    const container = document.getElementById('now-playing');
    const trackName = document.getElementById('track-name');
    const artistName = document.getElementById('artist-name');
    const albumImage = document.getElementById('album-image') as HTMLImageElement;
    const spotifyLink = document.getElementById('spotify-link') as HTMLAnchorElement;
   
    // If offline, show offline state
    if (!isOnline) {
      trackName.textContent = 'Currently Offline';
      artistName.textContent = "We'll be back at 4PM";
      albumImage.classList.add('hidden');
      spotifyLink.href = '#';
      container.classList.remove('hidden');
      return;
    }

    if (!trackData || !trackData.track) {
      container.classList.add('hidden');
      spotifyLink.href = '#';
      return;
    }

    const track = trackData.track;
   

    // Update track info
    trackName.textContent = track.name;
    artistName.textContent = track?.artist || track?.artists?.map(artist => artist.name).join(', ');
    spotifyLink.href = track?.url || '#';
    // Update album art
    if (track.image) {
      albumImage.src = track.image;
      albumImage.classList.remove('hidden');
    }

    // Show the container
    container.classList.remove('hidden');
  };

  const formatTime = (ms) => {
    const minutes = Math.floor(ms / 60000);
    const seconds = Math.floor((ms % 60000) / 1000);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  const showFallbackData = () => {
    // Use the last successful data if available, otherwise show loading
    if (lastSuccessfulData) {
      console.log('Using last successful data as fallback');
      updateDisplay(lastSuccessfulData);
    } else {
      console.log('No previous data available, showing loading state');
      const container = document.getElementById('now-playing');
      const trackName = document.getElementById('track-name');
      const artistName = document.getElementById('artist-name');
      
      trackName.textContent = 'Loading...';
      artistName.textContent = 'Loading...';
      container.classList.remove('hidden');
    }
  };

  const nowPlaying = async () => {
    try {
      // Fetch now playing data from Supabase database
      const { data, error } = await supabase
        .from('now_playing')
        .select('details, status')
        .eq('id', 1)
        .single();

      if (error) {
        console.error('Error fetching now playing data:', error);
        showFallbackData();
        return;
      }

      if (data) {
        // console.log('Now playing data:', data);
        const isOnline = data.status !== false; // default to true if status is null/undefined
        
        if (data.details && isOnline) {
          // Store the successful data
          lastSuccessfulData = data.details;
          updateDisplay(data.details, isOnline);
        } else {
          updateDisplay(null, isOnline);
        }
        isInitialized = true;
      } else {
        // console.log('No now playing data found');
        showFallbackData();
      }
    } catch (error) {
      console.error('Error fetching now playing:', error);
      showFallbackData();
    }
  };

  // Realtime subscription to updates on now_playing where id = 1
  let realtimeChannel = null;
  const subscribeToNowPlaying = () => {
    try {
      // Remove any existing channel before creating a new one
      if (realtimeChannel) {
        supabase.removeChannel(realtimeChannel);
      }

      realtimeChannel = supabase
        .channel('now-playing-row')
        .on(
          'postgres_changes',
          { event: 'UPDATE', schema: 'public', table: 'now_playing', filter: 'id=eq.1' },
          (payload) => {
            const updated = payload?.new;
            const details = updated?.details;
            const status = updated?.status;
            const isOnline = status !== false; // default to true if status is null/undefined
            
            if (details && isOnline) {
              lastSuccessfulData = details;
              updateDisplay(details, isOnline);
            } else {
              updateDisplay(null, isOnline);
            }
          }
        )
        .subscribe((status) => {
          if (status === 'SUBSCRIBED') {
            // console.log('Subscribed to now_playing updates');
          }
        });

      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        if (realtimeChannel) {
          supabase.removeChannel(realtimeChannel);
        }
      });
    } catch (e) {
      console.error('Error subscribing to now_playing realtime:', e);
    }
  };

  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    // Initial fetch
    nowPlaying();
    // Subscribe to realtime changes
    subscribeToNowPlaying();
  });
</script>

<style>
  #now-playing {
    backdrop-filter: blur(10px);
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(254, 233, 106, 0.3);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
  }

  #progress-bar {
    transition: width 1s linear;
  }

  #play-pause-btn:hover {
    transform: scale(1.05);
  }
</style>
